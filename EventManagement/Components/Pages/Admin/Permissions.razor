@page "/admin/permissions"
@using EventManagement.Security
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize(Policy = EventManagement.Security.Permissions.Names.ManageRoles)]
@inject HttpClient Http
@inject NavigationManager Nav

<h3 class="mb-3">Role permissions</h3>

@if (loading)
{
    <div class="spinner-border" role="status"><span class="visually-hidden">Loading…</span></div>
}
else if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger">@error</div>
}
else
{
    <div class="table-responsive">
        <table class="table table-sm align-middle">
            <thead>
                <tr>
                    <th>Permission</th>
                    @foreach (var role in roles)
                    {
                        <th class="text-center">@role</th>
                    }
                </tr>
            </thead>
            <tbody>
                @foreach (var perm in allPerms)
                {
                    <tr>
                        <td><code>@perm</code></td>
                        @foreach (var role in roles)
                        {
                            var has = matrix.TryGetValue(role, out var arr) && arr.Contains(perm, StringComparer.OrdinalIgnoreCase);
                            <td class="text-center">
                                <input type="checkbox" checked="@has"
                                       @onchange="async e => await Toggle(role, perm, ((bool?)e.Value) ?? false)" />
                            </td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code {
    // role -> perm[] (ritorna da /admin/permissions)
    private Dictionary<string, string[]> matrix = new(StringComparer.OrdinalIgnoreCase);
    private List<string> roles = new();
    private List<string> allPerms = new();
    private bool loading = true;
    private string? error;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            loading = true;
            // GET /admin/permissions  => { "Admin": ["events.manage", ...], "Supervisor": [...] }
            matrix = await Http.GetFromJsonAsync<Dictionary<string, string[]>>("/admin/permissions")
                     ?? new(StringComparer.OrdinalIgnoreCase);

            roles = matrix.Keys.OrderBy(r => r).ToList();

            // tutti i permessi usati (se hai dato tutto al Supervisor vedrai l'elenco completo)
            allPerms = matrix.Values.SelectMany(v => v).Distinct(StringComparer.OrdinalIgnoreCase)
                                   .OrderBy(p => p).ToList();
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
        finally
        {
            loading = false;
        }
    }

    private async Task Toggle(string role, string perm, bool nowChecked)
    {
        try
        {
            var url = nowChecked
                ? $"/admin/permissions/grant?role={Uri.EscapeDataString(role)}&perm={Uri.EscapeDataString(perm)}"
                : $"/admin/permissions/revoke?role={Uri.EscapeDataString(role)}&perm={Uri.EscapeDataString(perm)}";

            var resp = await Http.PostAsync(url, content: null);
            if (!resp.IsSuccessStatusCode)
            {
                error = $"Server returned {(int)resp.StatusCode}";
                return;
            }

            // aggiorna la matrice client-side
            var current = matrix.TryGetValue(role, out var arr) ? arr.ToList() : new List<string>();
            if (nowChecked)
            {
                if (!current.Contains(perm, StringComparer.OrdinalIgnoreCase)) current.Add(perm);
            }
            else
            {
                current.RemoveAll(p => string.Equals(p, perm, StringComparison.OrdinalIgnoreCase));
            }
            matrix[role] = current.OrderBy(p => p).ToArray();
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
    }
}
